# -*- coding: utf-8 -*-
"""B20CI034 AND B20AI037 SNS PA

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16oAiSSBHqMfSmk_6_7p3rccWS-h4q8w2
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import cmath as cm

df = pd.read_csv(r"data.csv")
# reading out our dataset and storing it in df dataframe
# function for finding sum of values in list



def sum_val(a):
    p = 0
    n = len(a)
    for i in a:
        p += i
    return p



def DTFT(a):
    
    # dtft = discrete time fourier transformation

    length = len(a)
    # length variable stores the number of values in a

    # taking an empty list
    X = []

    # here we are considering 2 for loops as there are 2 variables in the equation
    for x in range(length):
        p = 0
        q = 0
        for y in a:
            #formula for dtft
            # sum of a[j]e^(-j*2pie*j*i/length)
            # for taking exponenial and pi value we are importing cmath
            p += y * cm.exp(-2j * cm.pi * x * q / length)
            q += 1
        X.append(p)
        p = 0
        q = 0
    return np.array(X)
# returning the array after applying discrete fourier tranformation to the given list




def IFT(a):
    # IFT=inverse fourier transformation
    # this is the exact inverse of dtft
    # the process almost remains the same but in the end we divide the result with length
    length = len(a)
    X = []
    for x in range(length):
        p = 0
        q = 0
        for y in a:
            p += y * cm.exp(2j * cm.pi * q * x / length)
            q += 1
        X.append(p / length)
    return np.array(X)
# returning the array after applying inverse fourier transformation to the given list





hn = [1 / 16, 4 / 16, 6 / 16, 4 / 16, 1 / 16]
fourier_hn = DTFT(hn)
# here we need to apply dtft to hn which is provided in the question.
# hence we are calling DTFT function for hn




def removing_noise(yn):
    # this function is used for denoising

    a = []
    # first we are taking an empty list

    n = len(yn)
    for i in range(n):
        a.append(0)

    # for first element
    a[0] = sum_val(yn[0:3]) / 3

    # for second element
    a[1] = sum_val(yn[0:4]) / 4

    # for remaining elements between 2 to n-3
    for i in range(2, n - 2):
        a[i] = sum_val(yn[i - 2:i + 3]) / 5

    # for last element
    a[n - 1] = sum_val(yn[n - 3:]) / 3

    # for last but one element
    a[n - 2] = sum_val(yn[n - 4:]) / 4

    # returning the resulting list
    return a



def deblur_after_denoise(yn):
    # this is the first part of the question
    # here first we denoise and then we deblur
    # for denoising we call removing_noise function
    lst = np.array(removing_noise(yn))

    # taking an empty array b
    b = []

    n = len(yn)
    # n represents the length of yn

    for i in range(n):
        b.append(0)

    # first we are taking b of length n and elements as 0
    # for first element
    b[0] = (sum_val(IFT((DTFT((list(lst[0:3]) + list(lst[n - 2:])))) / fourier_hn))) / 5

    # for second element
    b[1] = (sum_val(IFT((DTFT((list(lst[0:4]) + list(lst[n - 1:])))) / fourier_hn))) / 5

    # for elements from 3 to n-3
    for j in range(2, n - 2):
        b[j] = (sum_val(IFT((DTFT((list(lst[j - 2:j + 3])))) / fourier_hn))) / 5

    # for last element
    b[n - 1] = (sum_val(IFT((DTFT((list(lst[0:2]) + list(lst[n - 3:])))) / fourier_hn))) / 5

    # for last but 1 element
    b[n - 2] = (sum_val(IFT((DTFT((list(lst[0:1]) + list(lst[n - 4:])))) / fourier_hn))) / 5

    return b




def deblur(yn):

    # taking an empty array b
    b = []

    n = len(yn)
    # n represents the length of yn

    for i in range(n):
        b.append(0)

    # first we are taking b of length n and elements as 0
    # for first element
    b[0] = (sum_val(IFT((DTFT((list(yn[0:3]) + list(yn[n - 2:])))) / fourier_hn))) / 5

    # for second element
    b[1] = (sum_val(IFT((DTFT((list(yn[0:4]) + list(yn[n - 1:])))) / fourier_hn))) / 5

    # for elements from 3 to n-3
    for j in range(2, n - 2):
        b[j] = (sum_val(IFT((DTFT((list(yn[j - 2:j + 3])))) / fourier_hn))) / 5

    # for last element
    b[n - 1] = (sum_val(IFT((DTFT((list(yn[0:2]) + list(yn[n - 3:])))) / fourier_hn))) / 5

    # for last but 1 element
    b[n - 2] = (sum_val(IFT((DTFT((list(yn[0:1]) + list(yn[n - 4:])))) / fourier_hn))) / 5

    return b





def denoise_after_deblur(yn):
    #here in this 2nd case we first deblur then denoise
    
    #first wr call deblur function for deblurring first
    b = np.array(deblur(yn))

    a = []
    # first we are taking an empty list

    n = len(yn)
    #n is length of yn
    
    for i in range(n):
        a.append(0)

    # for first element
    a[0] = sum_val(b[0:3]) / 3

    # for second element
    a[1] = sum_val(b[0:4]) / 4

    # for remaining elements between 2 to n-3
    for i in range(2, n - 2):
        a[i] = sum_val(b[i - 2:i + 3]) / 5

    # for last element
    a[n - 1] = sum_val(b[n - 3:]) / 3

    # for last but one element
    a[n - 2] = sum_val(b[n - 4:]) / 4

    # returning the resulting list
    return a
# returning the resulting list after applying the required operations




#for plotting xn x1 and x2


index=20
xaxis=np.linspace(0,193,193)



yn = list(df["y[n]"])
xn=list(df["x[n]"])
x1=deblur_after_denoise(yn)
x2=denoise_after_deblur(yn)
print('The x1(n) for different values of y(n) \n',x1)
print('The x2(n) for different values of y(n) \n',x2)
plt.plot(xaxis,x1,label='x1')
plt.plot(xaxis,x2,label='x2')
plt.plot(xaxis,xn,label='xn')
plt.legend()
plt.show()